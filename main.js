import * as THREE from 'three';
import { MockAIDirector } from './ai-director.js';

// --- DOM & State ---
const hudTime = document.getElementById('hud-time');
const doorOverlay = document.getElementById('door-overlay');
const doorButtons = document.querySelectorAll('.door-choice');

const gameState = {
  time: 0,
  health: 100,
  keys: 0,
};

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const container = document.getElementById('game-container');
if (!container) {
  throw new Error('Game container not found');
}

// --- CAMERA ---
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

// --- RENDERER ---
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// --- PLAYER AND CONTROLS ---
const player = {
  mesh: new THREE.Mesh(
    new THREE.SphereGeometry(2, 16, 16),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  ),
  velocity: new THREE.Vector3(),
  direction: new THREE.Vector3(),
  speed: 20.0,
  turnSpeed: 2.0,
};
player.mesh.position.y = 10; // Start slightly above the ground
scene.add(player.mesh);

const keyboardState = {};
window.addEventListener('keydown', (e) => { keyboardState[e.code] = true; });
window.addEventListener('keyup', (e) => { keyboardState[e.code] = false; });

// --- CHUNK AND TERRAIN MANAGEMENT ---
const terrainWorker = new Worker('./terrain-worker.js', { type: 'module' });
const chunks = new Map();

const CHUNK_SIZE = 100;
const CHUNK_SEGMENTS = 50;
const terrainParams = {
  width: CHUNK_SIZE,
  height: CHUNK_SIZE,
  segments: CHUNK_SEGMENTS,
  scale: 0.1,
  amplitude: 15,
};

function generateChunks() {
  const CHUNK_GRID_RADIUS = 1; // Creates a 3x3 grid (2*1+1)
  for (let x = -CHUNK_GRID_RADIUS; x <= CHUNK_GRID_RADIUS; x++) {
    for (let z = -CHUNK_GRID_RADIUS; z <= CHUNK_GRID_RADIUS; z++) {
      const chunkId = `${x},${z}`;
      if (!chunks.has(chunkId)) {
        terrainWorker.postMessage({
          ...terrainParams,
          offsetX: x * CHUNK_SIZE,
          offsetZ: z * CHUNK_SIZE,
        });
      }
    }
  }
}

terrainWorker.onmessage = (event) => {
  const { heightmap, offsetX, offsetZ } = event.data;
  const chunkId = `${offsetX / CHUNK_SIZE},${offsetZ / CHUNK_SIZE}`;

  const geometry = new THREE.PlaneGeometry(
    terrainParams.width,
    terrainParams.height,
    terrainParams.segments,
    terrainParams.segments
  );
  geometry.rotateX(-Math.PI / 2);

  const vertices = geometry.attributes.position.array;
  for (let i = 0; i < heightmap.length; i++) {
    vertices[i * 3 + 1] = heightmap[i];
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({ color: 0x55aa55 });
  const terrainMesh = new THREE.Mesh(geometry, material);
  terrainMesh.position.set(offsetX, 0, offsetZ);

  scene.add(terrainMesh);
  chunks.set(chunkId, terrainMesh);
};

// Initial generation
generateChunks();
// Adjust camera for the new larger world
camera.position.set(0, 80, 150);
camera.lookAt(0, 0, 0);


// --- LIGHTING ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// The scene is empty until the terrain is generated by the worker.

// --- GAME LOOP LOGIC ---
const goal = new THREE.Mesh(
  new THREE.TorusKnotGeometry(5, 1.5, 100, 16),
  new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x333300 })
);
// Place goal on the furthest chunk
goal.position.set(0, 10, -1 * CHUNK_SIZE);
scene.add(goal);

function resetLevel() {
  player.mesh.position.set(0, 10, 0);
  player.mesh.rotation.set(0, 0, 0);
  gameState.time = 0;
  doorOverlay.classList.add('hidden');
}

doorButtons.forEach(button => {
  button.addEventListener('click', () => {
    const difficulty = button.dataset.difficulty;

    // Call the mock AI director
    const nextRunParams = MockAIDirector.getRunParameters(gameState, difficulty);
    console.log('AI Director returned:', nextRunParams);

    // In the future, these params would be used to configure the next level
    resetLevel();
  });
});


// --- ANIMATION LOOP ---
const clock = new THREE.Clock();
function animate() {
  requestAnimationFrame(animate);
  const deltaTime = clock.getDelta();

  // --- Player movement ---
  const moveDirection = new THREE.Vector3();
  if (keyboardState['KeyW']) {
    moveDirection.z -= 1;
  }
  if (keyboardState['KeyS']) {
    moveDirection.z += 1;
  }

  if (keyboardState['KeyA']) {
    player.mesh.rotation.y += player.turnSpeed * deltaTime;
  }
  if (keyboardState['KeyD']) {
    player.mesh.rotation.y -= player.turnSpeed * deltaTime;
  }

  if (moveDirection.lengthSq() > 0) {
    // get player's forward direction
    const forward = new THREE.Vector3();
    player.mesh.getWorldDirection(forward);

    // move player
    player.mesh.position.addScaledVector(forward, moveDirection.z * player.speed * deltaTime);
  }

  // --- Camera follow ---
  const idealOffset = new THREE.Vector3(0, 15, 30); // Behind, up, and away
  idealOffset.applyQuaternion(player.mesh.quaternion);

  const cameraTargetPosition = player.mesh.position.clone().add(idealOffset);
  camera.position.lerp(cameraTargetPosition, 0.1);

  // Look at a point slightly above the player
  const lookAtTarget = player.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
  camera.lookAt(lookAtTarget);

  // --- HUD Update ---
  gameState.time += deltaTime;
  hudTime.textContent = `Time: ${gameState.time.toFixed(1)}s`;

  // --- Goal Animation and Collision ---
  goal.rotation.y += 1 * deltaTime;
  goal.rotation.z += 0.5 * deltaTime;

  if (player.mesh.position.distanceTo(goal.position) < 10) {
    doorOverlay.classList.remove('hidden');
  }

  renderer.render(scene, camera);
}

animate();

// --- RESIZE HANDLER ---
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener('resize', onWindowResize, false);
