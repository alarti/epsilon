import * as THREE from 'three';

// --- SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const container = document.getElementById('game-container');
if (!container) {
  throw new Error('Game container not found');
}

// --- CAMERA ---
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 5;

// --- RENDERER ---
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// --- TERRAIN WORKER ---
console.log('Setting up terrain worker...');
const terrainWorker = new Worker('./terrain-worker.js', { type: 'module' });

// Define terrain parameters
const terrainParams = {
  width: 100,
  height: 100,
  segments: 50,
  scale: 0.1,
  amplitude: 10,
};

// Start terrain generation
terrainWorker.postMessage(terrainParams);

terrainWorker.onmessage = (event) => {
  console.log('Main thread received message from worker.');
  const { heightmap } = event.data;

  // --- TERRAIN MESH ---
  const geometry = new THREE.PlaneGeometry(
    terrainParams.width,
    terrainParams.height,
    terrainParams.segments,
    terrainParams.segments
  );
  // Rotate the geometry to be horizontal
  geometry.rotateX(-Math.PI / 2);

  // Displace vertices along the Y-axis
  const vertices = geometry.attributes.position.array;
  for (let i = 0; i < heightmap.length; i++) {
    // y-coordinate is at index i*3 + 1
    vertices[i * 3 + 1] = heightmap[i];
  }
  geometry.attributes.position.needsUpdate = true;
  geometry.computeVertexNormals(); // Recalculate normals for correct lighting

  const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, wireframe: false });
  const terrainMesh = new THREE.Mesh(geometry, material);

  scene.add(terrainMesh);

  // Adjust camera
  camera.position.set(0, 50, 100);
  camera.lookAt(0, 0, 0);
};


// --- LIGHTING ---
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(5, 10, 7.5);
scene.add(directionalLight);

// The scene is empty until the terrain is generated by the worker.

// --- ANIMATION LOOP ---
function animate() {
  requestAnimationFrame(animate);

  // Scene-level animations can go here

  renderer.render(scene, camera);
}

animate();

// --- RESIZE HANDLER ---
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

window.addEventListener('resize', onWindowResize, false);
